--------------------------------------------------------------------------------
:::::::::::> notes
--------------------------------------------------------------------------------

----------------------------------------------------------------------------
::::: todo
----------------------------------------------------------------------------

next items:
. loading seeds
. saving hashname
. packet parsing
. switching logic
. building a line


----------------------------------------------------------------------------
::::: snapshot
----------------------------------------------------------------------------

[rain test]$go run ./exercise.go
2014/05/04 15:20:41.870071 Starting exercise
2014/05/04 15:20:41.870263 Starting initialization of switch
2014/05/04 15:20:41.870270 Starting initialization of cipher sets
2014/05/04 15:20:41.870310 init cs2a...
2014/05/04 15:20:43.078745        csid: cs2a
2014/05/04 15:20:43.078774 fingerprint: 5a94f43fb6076add699f001db67604916d5a0adabf06a0125f177417b078bc39
2014/05/04 15:20:43.078783 init cs3a...
2014/05/04 15:20:43.078976        csid: cs3a
2014/05/04 15:20:43.078986 fingerprint: 913b9c437c7cfad9e16b569c2fb17292f7760269eebb197c5f48d74fddc90fae
2014/05/04 15:20:43.078993 Finished initialization of cipher sets
2014/05/04 15:20:43.078999 Starting hashname creation
2014/05/04 15:20:43.079033 switch hashname: f0ba6cb61921702ae646c7e487450036a0e21f5ac9398bd4bb8af98026900966
2014/05/04 15:20:43.079106 Finished hashname creation
2014/05/04 15:20:43.079116 Finished initialization of switch
2014/05/04 15:20:43.079122 Switch ready
2014/05/04 15:20:43.079164 Switch instance created: {f0ba6cb61921702ae646c7e487450036a0e21f5ac9398bd4bb8af98026900966}
2014/05/04 15:20:43.079178 Finished exercise (1.209129485s)




----------------------------------------------------------------------------
::::: reference
----------------------------------------------------------------------------
starting point: 
protocol (v2.1-pre)
. https://github.com/telehash/telehash.org/blob/master/protocol.md


go / workspace / project layout references:
. http://golang.org/doc/code.html#Organization
. https://code.google.com/p/go-wiki/wiki/GithubCodeLayout


cipher sets and golang

- cs1a
    . not sure there is a go implementation for ECC secp160r1

- cs2a
    https://godoc.org/code.google.com/p/go.crypto/rsa
    https://godoc.org/code.google.com/p/go.crypto/x509
    ...

- cs3a:
    For box and secretbox:
    https://godoc.org/code.google.com/p/go.crypto/nacl/box          // switch key pair
    https://godoc.org/code.google.com/p/go.crypto/nacl/secretbox    // line

    For onetimeauth, the nacl docs say that poly1305 is used, so
    look here for onetimeauth:
    https://godoc.org/code.google.com/p/go.crypto/poly1305
    This is the same thing used in crypto_secretbox.

    If the above will work, all the pieces for cs3a should be available.



----------------------------------------------------------------------------
::::: early design notes
----------------------------------------------------------------------------


----------------------------------
: Telehash Layers and the Lexicon
----------------------------------
This is an interpretation and not to be taken as official documentation.  Some
of these terms conflict or are a little different than the current protocol
specs.  


flow and layers:
Content flows over channels, inside channel packets.  Channel packets flow over
lines, inside line packets.  Line packets flow over a network transport, inside
transport packets (ex. UDP datagrams).


* SwitchInstance
This is sometimes called a switch or a hashname.  A single switch instance is
started by an application and provides the means for communicating with other
switches.  At creation, a switch instance generates key pairs for each cipher
set it can support.  These key pairs are used to generate parts and a
globally unique hashname.


* Channel(s)
Channels are logical constructs an application uses to pass data back and
forth.  There is a set of core channel types used by the telehash protocol,
but an application can also create custom channel types.  The core types are
"seek", "link", "peer", "connect", "bridge", "path".


* Channel Packets (Inner Packets)
Channel packets contain a json head and a body.  Channel packets are encrypted and
then sent over a line.  


* Line(s)
Lines are virtual connections between two switch instances, protected by
encryption.  The encryption used is based on the best common cipher set
supported by each switch instance.


* Line Packets (Outer Packets)
Line packets contain a head and a body.  The body is often a channel packet
wrapped in an additional layer of encryption.  Line packets wrap and transmit
these channel packets over a network transport.

The basic line packet types are "open" (open a new line) and "line" (data).
Despite the name line packet, there can also be other types of outer packets
which are specific to the network transport (discovery, routing, etc).


* Network Transport(s)
A network transport is used to transmit Telehash Packets.  This could be UDP,
TCP, HTTP, Bluetooth, and more.


-- also:

* Packet
<2bytes-length-of-head>[Head][Body]

* Cipher Set

* Paths

* DHT / Links




----------------------- 
: notes on client api
-----------------------


------------begin
Adapted From:
https://github.com/telehash/telehash.org/blob/master/implementers.md

common api / patterns exposed by switch libs:

- generate a hashname
    . in: csids (optional)
    . do: gen new key pair, parts, and hashname
    . out: hashname
    . out: parts and keys

- switch creation / initialization
    . in: parts and keys
    . do: create a switch

- add seeds
    . load seeds from something like seeds.json

- start channel
    . in: hashname, type, initial json/body
    . do: initiate a channel
    . out: call an optional callback

- listen for channel
    . in: channel type and callback/event trigger
    . do: take action for incoming new channel of that type
------------end



other notes on client api:

- remember "net" in the golang std lib
    . interface of Dial, Listen, Accept.  may be applicable.
    . PacketConn


----------------------------------
: scratch notes on structures,
: types, files, etc
----------------------------------

These are just scratch notes and will not match final code design.

// local exerciser to help with testing
./exercise.go
    . switch
    . switch.init
    . ping?


// Switch provides a client api to applications using the library
. switch(s)
    . switch.init               // creates cipher sets and hashname
    . switch.load_from_file     // load previous


// Cipher sets produce keys and fingerprints
// Cipher sets also...
. cipher_sets
    . interface for CipherSet
        . generate()
        . encrypt_line_packet()
        . decrypt_line_packet()
    . type bundle of CipherSet          // csid, fingerprint, pub, priv
    . type bundle of CipherSetParts     // csid, fingerprint
    . cs1a
    . cs2a
    . cs3a - Use NaCl to help drive interface design and backfit
        . type CS3aCypherSet struct {
            type FingerPrint string
            type PublicKey []bytes
            type PrivateKey []bytes
            }
        . generate()
        . encrypt_line_packet()
        . decrypt_line_packet()


. hashname
. packet(s)
. line(s)
. channel(s)


----------------------------------
: switching logic
----------------------------------

::  inbound - request   (A request/session initiated by remote node)
::  inbound - response  (A response from a remote node
::  inbound - relay
:: outbound - request   (A request/session to a remote node, initiated by self)
:: outbound - response  (A response to a remote node)
:: outbound - relay


-------------------------
:: inbound - request
-------------------------
. transport packet in on listener
    . extract telehash packet from transport
    . udp?  simple 1:1
    . http?  unwrap from inside body of requests etc

. parse telehash outer packet (length, head, body)
    . switch {

        head-length == 1: line open packet
            head.1 is csid
            body.all is encrypted open request
            decrypt body to open request

        head-length == 0: line data packet 
            body.16 is line id
            match line id or drop
            body.rest is encrypted channel packet
            decrypt body to channel packet

        default:
            drop

    }

. parse telehash inner packet (length, head, body)

    . switch {

        type: line-open
            head is json (to, from, line, at)
            body is sender's public key (binary)
            
            

        type: line-data
    }

    . ...work in progress




--------------------------------------------------
fun fact

imp: interface message processor
the first switch/router devices on the arpanet
--------------------------------------------------

 
-------------------------
:: open handshake
-------------------------

sorting out the steps


. cipher set initialization at switch initialization
    . generate/use an instance level key pair (box.GenerateKey(rand.Reader))


. send: open request (cs3a)

    . generate a line id (16 random bytes lower case hex encoded)
    . generate a new line level key pair (crypto_box) (box.GenerateKey(rand.Reader))

    . encryption 
        . build the inner packet (json (to, from, parts, at) + switch public key)
        . generate a nonce
        . generate the 'agreedKey' (shared secret)
        . encrypt the inner packet using crypto_secretbox
        
        . prepend the line public key to make the open packet data

    . authentication
        . generate a macKey
        . use onetimeauth/poly1305 to generate an HMAC
        . prepend the hmac to the open packet data


. recv: open request (cs3a)

    . unpack the open packet

    . generate a line id (16 random bytes lower case hex encoded)
    . generate a new line level key pair (crypto_box) (box.GenerateKey(rand.Reader))

    . authentication
        . retrieve the hmac
        . generate a macKey
        . use onetimeauth/poly1305 verify to authenticate the packet

    . decryption 
        . generate a nonce
        . generate the 'agreedKey' (shared secret)
        . decrypt the inner packet using crypto_secretbox_open




-------------------------
:: line encrypt/decrypt
-------------------------




-eof
